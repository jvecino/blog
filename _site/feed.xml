<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2018-10-23T10:01:20+02:00</updated><id>http://localhost:4000/blog/feed.xml</id><title type="html">Joao Vecino tech blog</title><subtitle>Este blog nace de la necesidad personal de centralizar los conocimientos adquiridos de homelab, self hosting, nuevas técnologias, etc. No esta pensado para ser una fuente de tutoriales paso a paso sino más bien una serie de chuletas o cheatsheets rápidas que voy anotando por si algún día las necesito o a alguien le sean de ayuda. Lo dedico especialmente a todas aquellas personas que se esfuerzan en ser autodidáctas porque les encanta!</subtitle><author><name>Joao Carlos Correia Vecino Vieira</name></author><entry><title type="html">Instalar Pihole y Pivpn en Raspberry Pi</title><link href="http://localhost:4000/blog/raspberry/2018/10/23/install-pihole-and-pivpn.html" rel="alternate" type="text/html" title="Instalar Pihole y Pivpn en Raspberry Pi" /><published>2018-10-23T00:00:00+02:00</published><updated>2018-10-23T00:00:00+02:00</updated><id>http://localhost:4000/blog/raspberry/2018/10/23/install-pihole-and-pivpn</id><content type="html" xml:base="http://localhost:4000/blog/raspberry/2018/10/23/install-pihole-and-pivpn.html">&lt;h2 id=&quot;requisitos&quot;&gt;Requisitos:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Raspberry pi (Cualquier version)&lt;/li&gt;
  &lt;li&gt;microsd (2gb+)&lt;/li&gt;
  &lt;li&gt;Cable Ethernet&lt;/li&gt;
  &lt;li&gt;Cable microusb +&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;preparamos-la-sd-y-instalamos-raspbian&quot;&gt;Preparamos la SD y instalamos Raspbian.&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;Insertamos la SD. Si no tenemos lector de tarjetas sd en nuestro pc, nos valemos de cualquier adaptador de sd a usb.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/piholerasp1.png&quot; alt=&quot;pihole1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sacamos un CMD (Windows + R) y ejecutamos Diskpart&lt;/p&gt;

&lt;p&gt;Seguimos las siguientes instrucciones:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/piholerasp2.png&quot; alt=&quot;pihole2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Descargamos Raspbian stretch lite (sin escritorio) desde la página oficial de raspbian &lt;a href=&quot;https://www.raspberrypi.org/downloads/raspbian/&quot;&gt;AQUI&lt;/a&gt; y lo descomprimimos.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/piholerasp3.png&quot; alt=&quot;pihole3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Abrimos el programa Win32 Disk Imager y seleccionamos nuestra imagen. Nos lo descargamos gratuitamente desde &lt;a href=&quot;https://sourceforge.net/projects/win32diskimager/&quot;&gt;AQUI&lt;/a&gt;
&lt;img src=&quot;/blog/assets/img/piholerasp4.png&quot; alt=&quot;pihole4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Le damos a write para escribirla en la SD.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/piholerasp5.png&quot; alt=&quot;pihole5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ya tenemos nuestra SD preparada!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/piholerasp6.png&quot; alt=&quot;pihole6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Importante&lt;/strong&gt;: Si queremos conectarnos a nuestra raspberry por ssh sin necesidad de un monitor, previamente tendremos que crear un archivo vacio sin extensión que se llame “usb” en la raiz de nuestra SD después de haberle instalado Raspbian, así:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/piholerasp7.png&quot; alt=&quot;pihole7&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;instalamos-pihole-en-nuestro-raspbian&quot;&gt;Instalamos Pihole en nuestro Raspbian.&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;Originalmente Escrito por Valný  Ver Mensaje
Ya que esto se ha convertido en una quasi plataforma comparto por aquí un script para reconectar la red cuando se cae por si lo quieres añadir al OP. En mi caso la Raspberry arranca mucho más rápido que mi router y como detecta que no se puede conectar pues así se queda, como la tengo en modo headless lo único que puedo hacer es reiniciarla a la fuerza una vez el router ya está funcionando para que se conecte y empiece a funcionar bien.&lt;/p&gt;

&lt;p&gt;Creamos un script vacio con nano dentro de /usr/local/bin/ que se llamará wifi_check.sh:
Código:
sudo nano /usr/local/bin/http://wifi_check.shEl contenido del script es el siguiente:
Código:
#!/bin/bash&lt;/p&gt;

&lt;p&gt;SERVER=8.8.8.8&lt;/p&gt;

&lt;p&gt;ping -c2 ${SERVER} &amp;gt; /dev/null&lt;/p&gt;

&lt;p&gt;if [ $? != 0 ]
then
    sudo ifconfig wlan0 down
    sudo ifconfig wlan0 up
fi
Resumiendo manda dos pings al DNS de Google (8.8.8.8) si el resultado es distinto a 0 significa que no ha podido contactar y entonces reinicia la interfaz inalámbrica (si lo queréis para una Raspberry conectada por cable cambiar wlan0 por eth0)&lt;/p&gt;

&lt;p&gt;Guardamos con CTRL+O y salimos con CTRL+X.&lt;/p&gt;

&lt;p&gt;Damos permisos de ejecución al script:
Código:
sudo chmod +x /usr/local/bin/http://wifi_check.shAhora editaremos cron para que el script se ejecute automáticamente cada 5 minutos:
Código:
sudo nano /etc/crontab
Y añadimos al final del archivo la siguiente línea:&lt;/p&gt;

&lt;p&gt;Y ya está, si queréis probar que funciona podéis parar la red inalámbrica con:&lt;/p&gt;

&lt;p&gt;Esto desconectará la sesión SSH (y si lo tenéis configurado como único DNS en el router también desconectará internet en general), esperad 5 minutos y tratad de conectaros a la Raspberry de nuevo, si funciona es que lo habéis hecho bien&lt;/p&gt;</content><author><name>Joao Carlos Correia Vecino Vieira</name></author><summary type="html">Requisitos:</summary></entry><entry><title type="html">Duckdns en Docker</title><link href="http://localhost:4000/blog/docker/2018/10/19/Uso-de-duckdns.html" rel="alternate" type="text/html" title="Duckdns en Docker" /><published>2018-10-19T00:00:00+02:00</published><updated>2018-10-19T00:00:00+02:00</updated><id>http://localhost:4000/blog/docker/2018/10/19/Uso-de-duckdns</id><content type="html" xml:base="http://localhost:4000/blog/docker/2018/10/19/Uso-de-duckdns.html">&lt;h1 id=&quot;ducksdns-en-docker&quot;&gt;Ducksdns en Docker&lt;/h1&gt;
&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;El DNS dinámico (DDNS) es un servicio que permite la actualización en tiempo real de la información sobre nombres de dominio situada en un servidor de nombres. El uso más común que se le da es permitir la asignación de un nombre de dominio de Internet a un dispositivo con dirección IP variable (dinámica). Esto permite conectarse con la máquina en cuestión sin necesidad de tener conocimiento de que dirección IP posee en ese momento.&lt;/p&gt;

  &lt;p&gt;El DNS dinámico hace posible utilizar un software de servidor en un dispositivo con dirección IP dinámica (como la suelen facilitar muchos ISP) para, por ejemplo, alojar un sitio web en la PC de nuestra casa, sin necesidad de contratar un hosting de terceros.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;creación-del-subdominio&quot;&gt;Creación del subdominio&lt;/h2&gt;

&lt;p&gt;Entramos a la web de duckdns por este &lt;a href=&quot;https://www.duckdns.org&quot; title=&quot;duckdns&quot;&gt;enlace&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/duckdns1.png&quot; alt=&quot;duckdns1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Elegimos el subdominio que queramos y le damos a add domain y nos apuntamos el token para mas adelante.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/duckdns2.png&quot; alt=&quot;duckdns2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;creación-del-contenedor-de-docker&quot;&gt;Creación del contenedor de docker&lt;/h2&gt;

&lt;p&gt;Creamos el contenemos de duckdns para que tengamos siempre nuestro subdominio actualizado con nuestra ip actual, con los datos proporcionados al crear el subdominio en duckdns.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d --name='duckdns' \
--net='host' \
-e TZ=&quot;Europe/Paris&quot; \
-e 'SUBDOMAINS'='NUESTRO SUBDOMINIO DE DUCKDNS' \
-e 'TOKEN'='NUESTRO TOKEN' \
-e 'PUID'='ID USUARIO' \
-e 'PGID'='ID GRUPO' \
--memory=1024m \
'linuxserver/duckdns'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Este contenedor tiene habilitado un cron que actualiza la ip, si hace falta, cada 15 minutos.&lt;/p&gt;

&lt;p&gt;Si tenemos ip dinámica y necesitamos dar una dirección estática para algún servicio como nextcloud ya podremos usar nuestro ddns.&lt;/p&gt;</content><author><name>Joao Carlos Correia Vecino Vieira</name></author><summary type="html">Ducksdns en Docker</summary></entry><entry><title type="html">Como ejecutar pihole en docker</title><link href="http://localhost:4000/blog/docker/2018/10/16/pihole-docker.html" rel="alternate" type="text/html" title="Como ejecutar pihole en docker" /><published>2018-10-16T00:00:00+02:00</published><updated>2018-10-16T00:00:00+02:00</updated><id>http://localhost:4000/blog/docker/2018/10/16/pihole-docker</id><content type="html" xml:base="http://localhost:4000/blog/docker/2018/10/16/pihole-docker.html">&lt;h1 id=&quot;que-es-pi-hole&quot;&gt;¿Que es PI-HOLE&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;Pi-hole es un &lt;strong&gt;servidor dns&lt;/strong&gt; concebido para ayudarnos a bloquear publicidad, malware, mineria de monedas y sitios no deseados mientras navegamos.&lt;/p&gt;

&lt;p&gt;Las &lt;strong&gt;ventajas&lt;/strong&gt; de tener a pihole son muchas, entre ellas, menor consumo de ancho (ahorrarás datos), mejora en la experiencia de navegación, rapidez de carga, etc…&lt;/p&gt;

&lt;p&gt;Cuando tengamos Pi-hole funcionando podremos asignar la ip de este a nuestro router como DNS único. De este modo cuando hagamos una consulta con nuestro navegador, esta será filtrada por Pi-hole y este la bloqueará o la rediccionará a nuestro dns alternativo que configuremos desde el panel de administración.&lt;/p&gt;

&lt;p&gt;Pi-hole Funciona en nuestra red interna pero &lt;strong&gt;podremos extender su capacidad si nos conectamos por VPN&lt;/strong&gt;, de este modo las consultas que hagamos pasarán por nuestro DNS.&lt;/p&gt;

&lt;p&gt;Pi-hole &lt;strong&gt;no filtrará el 100% de publicidad o webs fraudulentas&lt;/strong&gt; y en algunas ocasiones desechará contenido que realmente queremos, para esto tendremos que acceder al panel de administración de Pi-hole y poner la web que queramos &lt;strong&gt;acceder en la lista de whitelist&lt;/strong&gt; o la que queramos &lt;strong&gt;bloquear en blacklist&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Pi-hole se nutre de listados de webs realizado por la comunidad de usuarios.&lt;/p&gt;

&lt;p&gt;En mi caso uso el listado de &lt;strong&gt;Block list project&lt;/strong&gt; que lo podrás encontrar en el siguiente &lt;a href=&quot;https://tspprs.com/&quot; title=&quot;Block list project&quot;&gt;enlace&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;ejecutando-pi-hole-por-primera-vez&quot;&gt;Ejecutando PI-HOLE por primera vez&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;Para ejecutar este docker lanzamos desde un &lt;strong&gt;cmd si estamos en windows&lt;/strong&gt;, o un &lt;strong&gt;terminal si estamos en mac o linux&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d \
--name='pihole' \
--net='br0' \
--ip='192.168.1.22' \
-e TZ=&quot;Europe/Madrid&quot; \
-e HOST_OS=&quot;Unraid&quot; \
-e 'TCP_PORT_53'='5355' \
-e 'UDP_PORT_53'='5355' \
-e 'TCP_PORT_80'='8055' \
-e 'PUID'='99' \
-e 'PGID'='100' \
-e 'ServerIP'='192.168.1.22' \
-e 'ServerIPv6'='' \
-e 'DNS1'='8.8.8.8' \
-e 'DNS2'='8.8.4.4' \
-e 'IPv6'='False' \
-e 'WEBPASSWORD'='YOURPASSWORD' \
-e 'DNSMASQ_LISTENING'='all' \
-v '/mnt/user/appdata/pihole/pihole/':'/etc/pihole/':'rw' \
-v '/mnt/user/appdata/pihole/dnsmasq.d/':'/etc/dnsmasq.d/':'rw' \
--cap-add=NET_ADMIN \
--dns 127.0.0.1 \
--dns 1.1.1.1 \
--restart=unless-stopped \
'pihole/pihole:latest' \
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;nos-conectamos-por-web-a-nuestra-instancia-de-pi-hole&quot;&gt;Nos conectamos por web a nuestra instancia de Pi-HOLE&lt;/h1&gt;
&lt;hr /&gt;

&lt;p&gt;Este es el aspecto que tendrá nuestra web si se ha cargado bien.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/pihole1.png&quot; alt=&quot;pihole1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Si seguimos el link o vamos directamente a la url del panel &lt;strong&gt;/admin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/pihole2.png&quot; alt=&quot;pihole2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pinchamos en Login y metemos el password que hemos puesto en la config del contenedor&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/pihole3.png&quot; alt=&quot;pihole3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Por defecto pihole viene con una blocklist extensa, pero si queremos mas, podremos añadir la lista que queramos en &lt;strong&gt;settings &amp;gt; blocklists&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/pihole4.png&quot; alt=&quot;pihole4&quot; /&gt;&lt;/p&gt;</content><author><name>Joao Carlos Correia Vecino Vieira</name></author><summary type="html">¿Que es PI-HOLE</summary></entry><entry><title type="html">Como hacer passthrough the una NIC a una VM en Unraid</title><link href="http://localhost:4000/blog/unraid/2018/10/12/unraid-nic-passthrough.html" rel="alternate" type="text/html" title="Como hacer passthrough the una NIC a una VM en Unraid" /><published>2018-10-12T00:00:00+02:00</published><updated>2018-10-12T00:00:00+02:00</updated><id>http://localhost:4000/blog/unraid/2018/10/12/unraid-nic-passthrough</id><content type="html" xml:base="http://localhost:4000/blog/unraid/2018/10/12/unraid-nic-passthrough.html">&lt;h1&gt;Como hacer passthrough the una NIC a una VM en Unraid&lt;/h1&gt;
&lt;hr /&gt;

&lt;h5&gt;&lt;em&gt;Acrónimos: VM (máquina virtual), NIC (tarjeta de red)&lt;/em&gt;&lt;/h5&gt;

&lt;p&gt;A la hora de crear una VM, si el rendimiento es una prioridad, la VM necesita tener acceso directo a todo el hardware posible de nuestro servidor.&lt;/p&gt;

&lt;p&gt;Con esto nos quitamos los problemas que pueden surgir de la virtualización dado que este hardware no estará emulado. Conseguiremos un rendimiento máximo del componente y evitaremos que unraid intervenga en el funcionamiento de este.&lt;/p&gt;

&lt;p&gt;Para este proposito necesitamos unraid y una tarjeta de red que vayamos a dedicar a una o varias VM (en el caso de que tenga mas de un puerto)&lt;/p&gt;

&lt;p&gt;Cada puerto se puede asignar individualmente a una VM.&lt;/p&gt;

&lt;p&gt;Vamos allá:&lt;/p&gt;

&lt;h2&gt;Asegurarse de que nuestra cpu admita IOMMU&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/blog/assets/img/nic-pass-1.png&quot; alt=&quot;iommu&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Verificar si nuestra NIC esta en un grupo de IOMMU separado&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/blog/assets/img/nic-pass-2.png&quot; alt=&quot;iommu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;En nuestro caso no lo está&lt;/p&gt;

&lt;p&gt;Para solucionar esto hay que ir a &lt;strong&gt;Settings&lt;/strong&gt; &amp;gt; &lt;strong&gt;Vm Manager&lt;/strong&gt; &amp;gt; &lt;strong&gt;PCIe ACS override&lt;/strong&gt; &amp;gt; &lt;strong&gt;Enable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nota: Antes tendremos que parar el servicio de VM desde el VM manager&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Nos pedirá reiniciar el servidor.&lt;/p&gt;

&lt;h2&gt;Identificar nuestra NIC en Unraid&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Abrimos una terminal en el servidor y ejecutamos&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Tower:~#lspci -n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;09:00.0 Ethernet controller: Intel Corporation 82571EB/82571GB Gigabit Ethernet Controller (Copper) (rev 06)&amp;lt;br&amp;gt;
09:00.1 Ethernet controller: Intel Corporation 82571EB/82571GB Gigabit Ethernet Controller (Copper) (rev 06)&amp;lt;br&amp;gt;
0a:00.1 Ethernet controller: Intel Corporation 82571EB/82571GB Gigabit Ethernet Controller (Copper) (rev 06)&amp;lt;br&amp;gt;
0a:00.0 Ethernet controller: Intel Corporation 82571EB/82571GB Gigabit Ethernet Controller (Copper) (rev 06)&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Nos saldrá nuestra NIC y todo el demás hardware.&lt;/p&gt;

&lt;p&gt;En nuestro caso es una nic de 4 puertos.&lt;/p&gt;

&lt;p&gt;Ejecutamos&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@Tower:~# lspci -n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;09:00.0 0200: 8086:10bc (rev 06)
09:00.1 0200: 8086:10bc (rev 06)
0a:00.0 0200: 8086:10bc (rev 06)
0a:00.1 0200: 8086:10bc (rev 06)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Buscamos los ids que coincidan y el dato que necesitamos es el de la parte derecha. En nuestro caso &lt;strong&gt;8086:10bc&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Decirle a Unraid que no use la NIC&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Nos vamos a &lt;strong&gt;Main&lt;/strong&gt; &amp;gt; &lt;strong&gt;Flash&lt;/strong&gt; &amp;gt; &lt;strong&gt;Syslinux Configuration&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Y en label UNRAID OS cambiamos la linea de append y agregamos ‘pci-stub.ids=8086:10bc’:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;label unRAID OS&amp;lt;br&amp;gt;
    menu default&amp;lt;br&amp;gt;
    kernel /bzimage&amp;lt;br&amp;gt;
    append pci-stub.ids=8086:10bc initrd=/bzroot&amp;lt;br&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Guardamos y reiniciamos el servidor.&lt;/p&gt;

&lt;p&gt;Con esto a la hora de crear una VM ya podremos seleccionar del listado la NIC para asignarla directamente.&lt;/p&gt;

&lt;p&gt;Este mismo proceso se puede usar para hacer passthrough a otros componentes y periféricos, como GPUs, hubs usb, discos duros etc…&lt;/p&gt;</content><author><name>Joao Carlos Correia Vecino Vieira</name></author><summary type="html">Como hacer passthrough the una NIC a una VM en Unraid</summary></entry><entry><title type="html">Instalar y usar Elasticsearch en nextcloud</title><link href="http://localhost:4000/blog/nextcloud/2018/10/09/elasticsearch-install-nextcloud.html" rel="alternate" type="text/html" title="Instalar y usar Elasticsearch en nextcloud" /><published>2018-10-09T00:00:00+02:00</published><updated>2018-10-09T00:00:00+02:00</updated><id>http://localhost:4000/blog/nextcloud/2018/10/09/elasticsearch-install-nextcloud</id><content type="html" xml:base="http://localhost:4000/blog/nextcloud/2018/10/09/elasticsearch-install-nextcloud.html">&lt;h1&gt;Instalación de Elasticsearch en Nextcloud&lt;/h1&gt;
&lt;hr /&gt;

&lt;h5&gt;Probado en ubuntu 16.04&lt;/h5&gt;

&lt;h2&gt;Instalación desde la appstore de Nextcloud&lt;/h2&gt;

&lt;p&gt;Logeate en tu instancia de Nextcloud, descarga el plugin y activalo&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/elasticsearchdownload.png&quot; alt=&quot;nextclouddownload&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Instalar Java&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo add-apt-repository ppa:webupd8team/java
sudo apt-get update
sudo apt update &amp;amp;&amp;amp; sudo apt install oracle-java8-installer &amp;amp;&amp;amp; sudo apt install oracle-java8-set-default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2&gt;Instalar y habilitar elasticsearch&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; echo &quot;deb https://artifacts.elastic.co/packages/6.x/apt stable main&quot; | sudo tee -a /etc/apt/sources.list.d/elastic-6.x.list
sudo apt update &amp;amp;&amp;amp; sudo apt install elasticsearch
sudo systemctl daemon-reload
sudo systemctl enable elasticsearch
sudo systemctl start elasticsearch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2&gt;Instalar plugin ingest-attachment de elasticsearch&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Así nextcloud podrá extraer archivos adjuntos en varios formatos&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo /usr/share/elasticsearch/bin/elasticsearch-plugin install ingest-attachment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2&gt;Cambiar elasticsearch para que solo escuche en localhost&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo nano /etc/elasticsearch/elasticsearch.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;y añade esta linea &lt;code&gt;network.host: 127.0.0.1&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;Reiniciar elasticsearch&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl restart elasticsearch
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2&gt;Comprobar que se está ejecutando elasticsearch&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo curl 'localhost:9200/?pretty'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2&gt;Configurar Nextcloud&lt;/h2&gt;
&lt;p&gt;Ir a &lt;strong&gt;Aplicaciones&lt;/strong&gt; &amp;gt; &lt;strong&gt;fulltextsearch&lt;/strong&gt; y cambiar la configuración a la siguiente:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/blog/assets/img/elasticsearchconfig.png&quot; alt=&quot;nextcloudconfig&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;Primera indexación masiva&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u www-data php /var/www/html/nextcloud/occ fulltextsearch:index
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2&gt;Enjoy!&lt;/h2&gt;</content><author><name>Joao Carlos Correia Vecino Vieira</name></author><summary type="html">Instalación de Elasticsearch en Nextcloud</summary></entry></feed>